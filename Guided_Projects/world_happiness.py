# -*- coding: utf-8 -*-
"""happiness.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FqAnGPBDXuR7ZFGFD0DyH5VtzX8uqchz

# World Happiness Report 2021

data:
https://www.kaggle.com/ajaypalsinghlo/world-happiness-report-2021/version/2
"""

# required dependencies
! pip install bubbly
! pip install iplot
! pip install chart_studio
!pip install jupyterthemes

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from sklearn.preprocessing import StandardScaler, normalize
from sklearn.cluster import KMeans
import plotly.express as px
import plotly.graph_objects as go
from chart_studio.plotly import plot, iplot
from plotly.offline import iplot

from jupyterthemes import jtplot
jtplot.style(theme='monokai', context='notebook', ticks=True, grid=False) 
# setting the style of the notebook to be monokai theme  
# this line of code is important to ensure that we are able to see the x and y axes clearly
# If you don't run this code line, you will notice that the xlabel and ylabel on any plot is black on black

"""## Exploring the Data"""

# Import csv file into pandas dataframe
df =  pd.read_csv('world-happiness-report-2021.csv')
df.head()

# size of dataframe
df.shape

# show Canada
df.loc[df['Country name'] == 'Canada']

# get summary
df.info()

# check for null
df.isnull().sum()

# statistical summary
df.describe()

# country with max happiness score
df[ df['Ladder score']>=7.842]

"""## Data Visualization"""

# Pairplot

fig = plt.figure(figsize = (20,20))
sns.pairplot(df[['Ladder score','Logged GDP per capita','Social support','Healthy life expectancy', 'Freedom to make life choices','Generosity', 'Perceptions of corruption']])

# Distribution Plot 

columns = ['Ladder score','Logged GDP per capita','Social support','Healthy life expectancy', 'Freedom to make life choices','Generosity', 'Perceptions of corruption']
plt.figure(figsize = (20,50))
for i in range(len(columns)):
  plt.subplot(8, 2, i+1)
  sns.distplot(df[columns[i]],  color = 'r')
  plt.title(columns[i])

plt.tight_layout()

# Correlation Matrix
corr_matrix = df.corr()
corr_matrix

plt.figure(figsize = (20,20))
sns.heatmap(corr_matrix, annot = True)

"""## Interactive Plots"""

# relationship between score, GDP, and region

rank = list(range(1, 150))
df.insert(0, column='Overall rank', value=rank)
fig = px.scatter(df, x='Logged GDP per capita', y = 'Ladder score', text='Country name', size='Overall rank', color='Country name')
fig.update_layout(title_text='Happiness Score vs GDP per Capita')
fig.show()

# Happiness vs Freedom to make life choices
plt.figure(figsize = (20,20))
fig = px.scatter(df, x='Freedom to make life choices', y = 'Ladder score', size='Overall rank', color='Country name')
fig.update_layout(title_text='Happiness Score vs Freedom to make life choices')
fig.show()

# Happiness Score vs Healthy life expectancy
plt.figure(figsize = (20,20))
fig = px.scatter(df, x='Healthy life expectancy', y = 'Ladder score', size='Overall rank', color='Country name')
fig.update_layout(title_text='Happiness Score vs Healthy life expectancy')
fig.show()

"""## K-Means"""

# drop rank and happiness score
df_happiness = df[columns]
df_seg = df_happiness.drop(columns =['Ladder score'])
df_seg.head()

scaler = StandardScaler()
scaled_data = scaler.fit_transform(df_seg) 
scaled_data.shape

# find optimal no. of clusters using elbow method
scores = []

range_values = range(1,20)

for i in range_values:
  kmeans = KMeans(n_clusters=i)
  kmeans.fit(scaled_data)
  scores.append(kmeans.inertia_)

plt.plot(scores,'bx-')
plt.title('Finding right number of clusters')
plt.xlabel('Clusters')
plt.ylabel('scores')
plt.show()

kmeans = KMeans(3)
kmeans.fit(scaled_data)

labels = kmeans.labels_

kmeans.cluster_centers_.shape

cluster_centers = pd.DataFrame(data = kmeans.cluster_centers_, columns=[df_seg])

cluster_centers = scaler.inverse_transform(cluster_centers)
cluster_centers = pd.DataFrame(data = cluster_centers, columns = [df_seg.columns])
cluster_centers

y_kmeans = kmeans.fit_predict(scaled_data)
y_kmeans

labels.shape

df_cluster = pd.concat([df,pd.DataFrame({'cluster':labels})], axis=1)
df_cluster

for i in df_seg.columns:
  plt.figure(figsize = (35,10))
  for j in range(3):
    plt.subplot(1,3,j+1)
    cluster = df_cluster[df_cluster['cluster']==j]
    cluster[i].hist(bins=20)
    plt.title('{}  \nCluster {} '.format(i,j))

plt.show()

from bubbly.bubbly import bubbleplot

figure = bubbleplot(dataset=df_cluster,
                    x_column='Logged GDP per capita', y_column='Perceptions of corruption', bubble_column='Country name',
                    color_column='cluster',z_column='Healthy life expectancy',size_column='Ladder score',
                    x_title='GDP per capita', y_title="Corruption",z_title="Life Expectancy",
                    title="Clusters based Impact of Economy, Corruption, and Life expectancy on Happiness Scores",
                    colorbar_title='Cluster',marker_opacity=1,colorscale='Portland',
                    scale_bubble=0.8, height=650)
                    
iplot(figure, config={'scrolllzoom': True})

# geo visualization

data = dict(type = 'choropleth',
            locations = df_cluster["Country name"],
            locationmode = 'country names',
            colorscale='RdYlGn',
            z=df_cluster['cluster'],
            text=df_cluster['Country name'],
            colorbar = {'title':'Clusters'})
            
layout = dict(title = 'Geographical Visualiztion of Clusters',
              geo = dict(showframe = True, projection = {'type': 'azimuthal equal area'}))

choromap3 = go.Figure(data=[data], layout=layout)
iplot(choromap3)

